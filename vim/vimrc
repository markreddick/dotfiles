scriptencoding utf-8
syntax on
" enable 256 color
set t_Co=256
"colorscheme jellybeans 
"colorscheme solarized
"colorscheme wombat256mod
"colorscheme mer-blue-bg
"colorscheme mer-blue
colorscheme mer-easy-custom
"colorscheme mer-minimal
" turn off colors on cursor line - if we have line heighlighted in any way, it
" turns special keys (tabs mainly) the "normal" color
"hi CursorLine ctermfg=NONE ctermbg=NONE cterm=NONE
" set color of non text chars (eol, extends and precedes)
"hi NonText ctermfg=235 ctermbg=NONE cterm=NONE
" set color of special keys (nbsp, tab and trail)
"hi SpecialKey ctermfg=235 ctermbg=NONE cterm=NONE
" set colored columns (to indicate desired line length) to dark gray
"hi colorcolumn ctermfg=NONE ctermbg=235 cterm=NONE
set colorcolumn=80,120
"let &colorcolumn="80,".join(range(120,999),",")
"let &colorcolumn="80,".join(range(120,999),",")
set encoding=utf-8 fileencoding=utf-8 termencoding=utf-8	" saving and encoding
set nobackup nowritebackup noswapfile autoread				" no backup or swap
set hlsearch incsearch ignorecase smartcase					" search
set wildmenu wildmode=longest:full,full						" completion
set backspace=indent,eol,start								" sane backspace
set clipboard=unnamedplus									" use system clipboard for yank/pul/delete
set nomousehide												" don't hide the mouse cursor while typing
set mouse=n													" enable mouse support in normal mode
set mousemodel=popup										" right-click pops up context menu
set ruler													" show cursor position in status bar
set number													" show line numbers on left
set nofoldenable											" don't allow code folding
set scrolloff=3												" scroll the window so we can always see x lines around the cursor
"set cursorline												" highlight the current line // NOTE: THIS SEEMS TO GREATLY SLOW DOWN SCROLLING IF ENABLED
"set nowrap													" don't wrap lines
set wrap													" wrap lines
set textwidth=0 wrapmargin=0								" turn off physical line wrapping (ie: automatic insertion of newlines)
set tabstop=4 shiftwidth=4 softtabstop=4 noexpandtab		" 4 space tabstops
"set listchars=space:.,nbsp:_,tab:>—,eol:$,trail:-			" show tabstops visually
"set listchars=nbsp:·,tab:>—,trail:·							" show tabstops visually
"set listchars=nbsp:·,tab:▶▹,trail:·
"set listchars=nbsp:·,tab:▶-,trail:·
set listchars=nbsp:·,tab:│·,trail:·
"set listchars=nbsp:·,tab:▒░,trail:·
set list													" turns on showing chars described in listchars
set showmatch												" highlights matching parens/brackets
set laststatus=2											" always enbale status line
set showtabline=2											" alwasys display tabline
set relativenumber											" in place of absolute line numbers, show relative from current // NOTE: THIS GREALY SLOWS DOWN SCROLLING WHEN ENABLED
set lazyredraw												" redraw screen less frequently - ths speeds up verticle scrolling so can now use relativenumber with acceptable scroll speed
set undofile												" create undo files so undos carry over even after closed
set undolevels=5000											" store up to 5000 levels of undo history
set undodir=$HOME/.vim/undo									" where to save undo files
set autoindent												" copy indent from prior line
set visualbell												" display visual bell instead of beeping
set ttyfast													" fast terminal connection
"set autochdir												" automatically charnge current working dir to file of current buffer
set viminfo='1000,f1,<500,%,n~/.vim/viminfo

"turn on the sign column always so it doesn't cause the whole window to move
"when there are signs or no signs to display
if exists('&signcolumn')
  set signcolumn=yes
else
  let g:gitgutter_sign_column_always = 1
endif

" configiure netrw to be like NERDtree
let g:netrw_banner = 0										" hide netrd banner (I to toggle)
let g:netrw_liststyle = 3									" show netrw tree with parent showing
"let g:netrw_browse_split = 0								" open file in same window on <cr>
let g:netrw_browse_split = 4								" open file in prior window on <cr>
let g:netrw_altv = 1 
let g:netrw_winsize = 25									" set netrw width to 25% of page

" php syntax options
let php_sql_query = 1										" highlight SQL syntax in strings
let php_htmlInStrings = 1									" highlight HTML in strings

let g:airline_powerline_fonts = 1

" unicode symbols
"let g:airline_left_sep = '»'
"let g:airline_left_sep = '▶'
"let g:airline_right_sep = '«'
"let g:airline_right_sep = '◀'
"let g:airline_symbols.linenr = '␊'
"let g:airline_symbols.linenr = '␤'
"let g:airline_symbols.linenr = '¶'
"let g:airline_symbols.branch = '⎇'
"let g:airline_symbols.paste = 'ρ'
"let g:airline_symbols.paste = 'Þ'
"let g:airline_symbols.paste = '∥'
"let g:airline_symbols.whitespace = 'Ξ'

" airline symbols
"let g:airline_left_sep = ''
"let g:airline_left_alt_sep = ''
"let g:airline_right_sep = ''
"let g:airline_right_alt_sep = ''
"let g:airline_symbols.branch = ''
"let g:airline_symbols.readonly = ''
"let g:airline_symbols.linenr = ''

function! GitBranchWithSymbol()
  if exists('*gitbranch#name')
    let branch_name = gitbranch#name()
	return strlen(branch_name) > 0 ? '  ' . branch_name . ' ' : ''
  else
    return ''
  endif
endfunction

"syntastic config
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0

" automatically open quickfix window after :make, :grep, etc
augroup autoquickfix
  autocmd!
  autocmd QuickFixCmdPost [^1]* cwindow
  autocmd QuickFixCmdPost 1* lwindow
augroup END

execute pathogen#infect()

" enable PHP autocomplete for all PHP files
autocmd FileType php set omnifunc=phpcomplete#CompletePHP

function! NumberToggle()
  if(&relativenumber == 1)
    set norelativenumber
	set nolazyredraw
  else
    set relativenumber
	set lazyredraw
  endif
endfunc

" show highlight groups
function! <SID>SynStack()
  if !exists("*synstack")
    return
  endif
  echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunc

set timeout timeoutlen=3000 ttimeoutlen=10	" time out on mapping after 3 seconds, on key codes after 1/100th sec

" key mappings
inoremap <c-F> <C-x><C-o>
inoremap <leader>p <ESC>:r ~/templates/phpdoc.php<CR>jA
inoremap <leader>d <ESC>:r ~/templates/phperron.php<CR>i
nnoremap <leader>d :bp\|bd #<CR>
nnoremap <leader>n :call NumberToggle()<CR>
nnoremap <leader>b :ls<CR>:b
nnoremap <leader>e :e **/*
nnoremap <leader>s :sp **/*
nnoremap <leader>cd :lcd %:p:h<CR>:pwd<CR>
"nnoremap <leader>t :NERDTreeToggle<CR>
nnoremap <leader>t :EasyTreeHere<CR>
nmap <leader>hl :call <SID>SynStack()<CR>
noremap <F5> :mks! ~/.vim/session/session_1<CR>
noremap <F6> :mks! ~/.vim/session/session_2<CR>
noremap <F7> :mks! ~/.vim/session/session_3<CR>
noremap <F8> :mks! ~/.vim/session/session_4<CR>
noremap <F9> :source ~/.vim/session/session_1<CR>
noremap <F10> :source ~/.vim/session/session_2<CR>
noremap <F11> :source ~/.vim/session/session_3<CR>
noremap <F12> :source ~/.vim/session/session_4<CR>
nnoremap <TAB> <C-W>w
nnoremap <s-TAB> <C-W>W

" my custom tab line and status line 
"
if !exists("g:merSection1FG")
  let g:merSection1FG=255
  let g:merSection1BG=33
  let g:merSection2FG=253
  let g:merSection2BG=27
  let g:merMainFG=253
  let g:merMainBG=21
  let g:merVisualFG=255
  let g:merVisualBG=202
  let g:merInsertFG=254
  let g:merInsertBG=28
  let g:merInactiveFG=249
  let g:merInactiveBG=237
endif

exec 'hi MERNormalSection ctermfg=' . g:merSection1FG . ' ctermbg=' . g:merSection1BG . ' cterm=NONE'
exec 'hi MERNormalSectionSep ctermfg=' . g:merSection1BG . ' ctermbg=' . g:merSection2BG . ' cterm=NONE'
exec 'hi MERVisualSection ctermfg=' . g:merVisualFG . ' ctermbg=' . g:merVisualBG . ' cterm=NONE'
exec 'hi MERVisualSectionSep ctermfg=' . g:merVisualBG . ' ctermbg=' . g:merSection2BG . ' cterm=NONE'
exec 'hi MERInsertSection ctermfg=' . g:merInsertFG . ' ctermbg=' . g:merInsertBG . ' cterm=NONE'
exec 'hi MERInsertSectionSep ctermfg=' . g:merInsertBG . ' ctermbg=' . g:merSection2BG . ' cterm=NONE'
 
exec 'hi MERMain ctermfg=' . g:merMainFG . ' ctermbg=' . g:merMainBG . ' cterm=NONE'
exec 'hi MERInactive ctermfg=' . g:merInactiveFG . ' ctermbg=' . g:merInactiveBG . ' cterm=NONE'
exec 'hi MERSection1 ctermfg=' . g:merSection1FG . ' ctermbg=' . g:merSection1BG . ' cterm=NONE'
exec 'hi MERSection1Sep ctermfg=' . g:merSection1BG . ' ctermbg=' . g:merSection2BG . ' cterm=NONE'
exec 'hi MERSection2 ctermfg=' . g:merSection2FG . ' ctermbg=' . g:merSection2BG . ' cterm=NONE'
exec 'hi MERSection2Sep ctermfg=' . g:merSection2BG . ' ctermbg=' . g:merMainBG . ' cterm=NONE'

exec 'hi MERTabMain ctermfg=' . g:merMainFG . ' ctermbg=' . g:merMainBG . ' cterm=NONE'
exec 'hi MERTab ctermfg=' . g:merSection2FG . ' ctermbg=' . g:merSection2BG . ' cterm=NONE'
exec 'hi MERTabSep ctermfg=' . g:merSection2BG . ' ctermbg=' . g:merSection1BG . ' cterm=NONE'
exec 'hi MERLastTabSep ctermfg=' . g:merSection2BG . ' ctermbg=' . g:merMainBG . ' cterm=NONE'
exec 'hi MERCurrentTab ctermfg=' . g:merSection1FG . ' ctermbg=' . g:merSection1BG . ' cterm=NONE'
exec 'hi MERCurrentTabSep ctermfg=' . g:merSection1BG . ' ctermbg=' . g:merSection2BG . ' cterm=NONE'
exec 'hi MERCurrentLastTabSep ctermfg=' . g:merSection1BG . ' ctermbg=' . g:merMainBG . ' cterm=NONE'

function! ActiveStatus()
  let sl=""
"
  if mode() == 'n'
    let sl .= "%#MERNormalSection# NORMAL %#MERNormalSectionSep#\ue0b0"
  elseif mode() == 'v'
    let sl .= "%#MERVisualSection# VISUAL %#MERVisualSectionSep#\ue0b0"
  elseif mode() == 'i'
    let sl .= "%#MERInsertSection# INSERT %#MERInsertSectionSep#\ue0b0"
  else
    let sl .= "%#MERNormalSection# " . mode() . " %#MERNormalSectionSep#\ue0b0"
  endif

  let sl.="%#MERSection2#"
  let sl.="%{GitBranchWithSymbol()}"
  let sl.="%#MERSection2Sep#\ue0b4"
  let sl.="%#MERMain#"
  let sl.=" %n:%f %r%m"
  let sl.="%<"
  let sl.="%="
  let sl.="%{&fileformat}"
  let sl.=" | %{&fileencoding?&fileencoding:&encoding}"
  let sl.=" | %Y "
  let sl.="%#MERSection2Sep#\ue0b2"
  let sl.="%#MERSection2#"
  let sl.="%4p%% "
  let sl.="%#MERSection1Sep#\ue0b2"
  let sl.="%#MERSection1#"
  let sl.=" %4l:%-3c "
"  let sl.=" %4l "
  return sl
endfunction

let g:LCARSBackground = 16
let g:LCARSOrange = 208
let g:LCARSMauve = 177
let g:LCARSCrimson = 167
let g:LCARSSky = 117
let g:LCARSBlue = 63
let g:LCARSAgua = 67
let g:LCARSPurple = 99
let g:LCARSPeach = 209
let g:LCARSMagenta = 169
let g:LCARSMelon = 223
let g:LCARSSlate = 105
let g:LCARSBurnt = 180
let g:LCARSYellow = 222
let g:LCARSGray = 60
let g:LCARS$ed = 196
let g:LCARSMaroon = 160
let g:LCARSPowder = 147


let g:LCARSEndOrange  ctermfg=16 ctermbg=208 cterm=NONE


exec 'hi LCARSOrange ctermfg=16 ctermbg=' . g:LCARSOrange . ' cterm=NONE'
exec 'hi LCARSEndOrange ctermfg=' . g:LCARSOrange . ' ctermbg=' . g:LCARSBackground . ' cterm=NONE'

function! ActiveStatus()
  let sl = ""
  let sl .= "%#LCARSIcon#"

function! InactiveStatus()
  let sl=""
  let sl.="%#MERInactive#"
  let sl.=" %n:%t %r%m"
  let sl.="%<"
  let sl.="%="
  let sl.=" %4l:%-3c "
  return sl
endfunction

function! GetMode()
  if mode() == 'n'
    return '%#MERNormalSection#NORMAL%#MERNormalSectionSep#\ue0b0'
  elseif mode() == 'v'
    return "%#MERVisualSection#VISUAL%#MERVisualSectionSep#\ue0b0"
  elseif mode() == 'i'
    return "%#MERInsertSection#INSERT%#MERInsertSectionSep#\ue0b0"
  else
    return mode()
endfunction


" call our color overrides script to override colors we want static
" no matter which color scheme we use (gray tabs, color columns, etc)
" - we have to do this via autocmd's otherwise if we load sessions
" it overrides these changes and only uses base color scheme
"autocmd VimEnter * source ~/.vim/mer_color_overrides.vim
"autocmd SessionLoadPost * source ~/.vim/mer_color_overrides.vim

set statusline=%!ActiveStatus()

autocmd WinEnter * setlocal statusline=%!ActiveStatus()
autocmd WinLeave * setlocal statusline=%!InactiveStatus()

function! MyTabLine()

	let s = ''
	
	for i in range(tabpagenr('$'))
		let tabnr = i + 1 " range() starts at 0
		let winnr = tabpagewinnr(tabnr)
		let buflist = tabpagebuflist(tabnr)
		let bufnr = buflist[winnr - 1]
		let bufname = fnamemodify(bufname(bufnr), ':t')

		let s .= '%' . tabnr . 'T'
		let s .= (tabnr == tabpagenr() ? '%#MERCurrentTab#' : '%#MERTab#')
		let s .= ' ' . tabnr 

		let n = tabpagewinnr(tabnr,'$')
		if n > 1 | let s .= ':' . n | endif

		let bufmodified = getbufvar(bufnr, "&mod")
		if bufmodified | let s .= '+' | endif
	
		let s .= empty(bufname) ? ' [No Name] ' : ' ' . bufname . ' '

		let simplesep = 0
		if (tabnr < tabpagenr('$'))
			if (tabpagenr() != tabnr) && (tabpagenr() != tabnr + 1)
				let s .= ''
				let simplesep = 1
			endif
		endif

		if simplesep == 0
			if tabnr == tabpagenr('$')
				let s .= (tabnr == tabpagenr() ? "%#MERCurrentLastTabSep#\ue0b0" : "%#MERLastTabSep#\ue0b0")
			else
				let s .= (tabnr == tabpagenr() ? "%#MERCurrentTabSep#\ue0b0" : "%#MERTabSep#\ue0b0")
			endif
		endif

	endfor

	" after the last tab fill with TabLineFill and reset tab page nr
	let s .= '%#MERMain#%T'

	if tabpagenr('$') > 1
		let s .= '%='
		let s .= "%#MERLastTabSep#\ue0b2"
		let s .= '%#MERTab#%999X X '
	endif
	
	return s

endfunction

set tabline=%!MyTabLine()
