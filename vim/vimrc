scriptencoding utf-8
syntax on
" enable 256 color
set t_Co=256
"colorscheme jellybeans 
"colorscheme solarized
"colorscheme wombat256mod
"colorscheme mer-blue-bg
"colorscheme mer-blue
colorscheme mer-easy-custom
"colorscheme mer-minimal
" turn off colors on cursor line - if we have line heighlighted in any way, it
" turns special keys (tabs mainly) the "normal" color
"hi CursorLine ctermfg=NONE ctermbg=NONE cterm=NONE
" set color of non text chars (eol, extends and precedes)
"hi NonText ctermfg=235 ctermbg=NONE cterm=NONE
" set color of special keys (nbsp, tab and trail)
"hi SpecialKey ctermfg=235 ctermbg=NONE cterm=NONE
" set colored columns (to indicate desired line length) to dark gray
"hi colorcolumn ctermfg=NONE ctermbg=235 cterm=NONE
set colorcolumn=80,120
"let &colorcolumn="80,".join(range(120,999),",")
"let &colorcolumn="80,".join(range(120,999),",")
set encoding=utf-8 fileencoding=utf-8 termencoding=utf-8	" saving and encoding
set nobackup nowritebackup noswapfile autoread				" no backup or swap
set hlsearch incsearch ignorecase smartcase					" search
set wildmenu wildmode=longest:full,full						" completion
set backspace=indent,eol,start								" sane backspace
set clipboard=unnamedplus									" use system clipboard for yank/pul/delete
set nomousehide												" don't hide the mouse cursor while typing
set mouse=n													" enable mouse support in normal mode
set mousemodel=popup										" right-click pops up context menu
set ruler													" show cursor position in status bar
set number													" show line numbers on left
set nofoldenable											" don't allow code folding
set scrolloff=3												" scroll the window so we can always see x lines around the cursor
set fillchars=vert:\ 
"set fillchars=vert:│
"set cursorline												" highlight the current line // NOTE: THIS SEEMS TO GREATLY SLOW DOWN SCROLLING IF ENABLED
"set nowrap													" don't wrap lines
set wrap													" wrap lines
set textwidth=0 wrapmargin=0								" turn off physical line wrapping (ie: automatic insertion of newlines)
set tabstop=4 shiftwidth=4 softtabstop=4 noexpandtab		" 4 space tabstops
"set listchars=space:.,nbsp:_,tab:>—,eol:$,trail:-			" show tabstops visually
"set listchars=nbsp:·,tab:>—,trail:·							" show tabstops visually
"set listchars=nbsp:·,tab:▶▹,trail:·
"set listchars=nbsp:·,tab:▶-,trail:·
set listchars=nbsp:·,tab:│·,trail:·
"set listchars=nbsp:·,tab:▒░,trail:·
set list													" turns on showing chars described in listchars
set showmatch												" highlights matching parens/brackets
set laststatus=2											" always enbale status line
set showtabline=2											" alwasys display tabline
set relativenumber											" in place of absolute line numbers, show relative from current // NOTE: THIS GREALY SLOWS DOWN SCROLLING WHEN ENABLED
set lazyredraw												" redraw screen less frequently - ths speeds up verticle scrolling so can now use relativenumber with acceptable scroll speed
set undofile												" create undo files so undos carry over even after closed
set undolevels=5000											" store up to 5000 levels of undo history
set undodir=$HOME/.vim/undo									" where to save undo files
set autoindent												" copy indent from prior line
set visualbell												" display visual bell instead of beeping
set ttyfast													" fast terminal connection
"set autochdir												" automatically charnge current working dir to file of current buffer
set viminfo='1000,f1,<500,%,n~/.vim/viminfo

"turn on the sign column always so it doesn't cause the whole window to move
"when there are signs or no signs to display
if exists('&signcolumn')
  set signcolumn=yes
else
  let g:gitgutter_sign_column_always = 1
endif

" configiure netrw to be like NERDtree
let g:netrw_banner = 0										" hide netrd banner (I to toggle)
let g:netrw_liststyle = 3									" show netrw tree with parent showing
"let g:netrw_browse_split = 0								" open file in same window on <cr>
let g:netrw_browse_split = 4								" open file in prior window on <cr>
let g:netrw_altv = 1 
let g:netrw_winsize = 25									" set netrw width to 25% of page

" php syntax options
let php_sql_query = 1										" highlight SQL syntax in strings
let php_htmlInStrings = 1									" highlight HTML in strings

let g:airline_powerline_fonts = 1

" unicode symbols
"let g:airline_left_sep = '»'
"let g:airline_left_sep = '▶'
"let g:airline_right_sep = '«'
"let g:airline_right_sep = '◀'
"let g:airline_symbols.linenr = '␊'
"let g:airline_symbols.linenr = '␤'
"let g:airline_symbols.linenr = '¶'
"let g:airline_symbols.branch = '⎇'
"let g:airline_symbols.paste = 'ρ'
"let g:airline_symbols.paste = 'Þ'
"let g:airline_symbols.paste = '∥'
"let g:airline_symbols.whitespace = 'Ξ'

" airline symbols
"let g:airline_left_sep = ''
"let g:airline_left_alt_sep = ''
"let g:airline_right_sep = ''
"let g:airline_right_alt_sep = ''
"let g:airline_symbols.branch = ''
"let g:airline_symbols.readonly = ''
"let g:airline_symbols.linenr = ''

function! GitBranchWithSymbol()
  if exists('*gitbranch#name')
    let branch_name = gitbranch#name()
	return strlen(branch_name) > 0 ? '  ' . branch_name . ' ' : ''
  else
    return ''
  endif
endfunction

"syntastic config
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0

" automatically open quickfix window after :make, :grep, etc
augroup autoquickfix
  autocmd!
  autocmd QuickFixCmdPost [^1]* cwindow
  autocmd QuickFixCmdPost 1* lwindow
augroup END


augroup relativenumbertoggle
  autocmd!
  autocmd WinEnter,FocusGained,InsertLeave * set relativenumber
  autocmd WinLeave,FocusLost,InsertEnter * set norelativenumber
augroup END

execute pathogen#infect()

" enable PHP autocomplete for all PHP files
autocmd FileType php set omnifunc=phpcomplete#CompletePHP

function! NumberToggle()
  if(&relativenumber == 1)
    set norelativenumber
	set nolazyredraw
  else
    set relativenumber
	set lazyredraw
  endif
endfunc

" show highlight groups
function! <SID>SynStack()
  if !exists("*synstack")
    return
  endif
  echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunc

set timeout timeoutlen=3000 ttimeoutlen=10	" time out on mapping after 3 seconds, on key codes after 1/100th sec

" key mappings
inoremap <c-F> <C-x><C-o>
inoremap <leader>p <ESC>:r ~/templates/phpdoc.php<CR>jA
inoremap <leader>d <ESC>:r ~/templates/phperron.php<CR>i
nnoremap <leader>d :bp\|bd #<CR>
nnoremap <leader>n :call NumberToggle()<CR>
nnoremap <leader>b :ls<CR>:b
nnoremap <leader>e :e **/*
nnoremap <leader>s :sp **/*
nnoremap <leader>cd :lcd %:p:h<CR>:pwd<CR>
"nnoremap <leader>t :NERDTreeToggle<CR>
nnoremap <leader>t :EasyTreeHere<CR>
nmap <leader>hl :call <SID>SynStack()<CR>
noremap <F5> :mks! ~/.vim/session/session_1<CR>
noremap <F6> :mks! ~/.vim/session/session_2<CR>
noremap <F7> :mks! ~/.vim/session/session_3<CR>
noremap <F8> :mks! ~/.vim/session/session_4<CR>
noremap <F9> :source ~/.vim/session/session_1<CR>
noremap <F10> :source ~/.vim/session/session_2<CR>
noremap <F11> :source ~/.vim/session/session_3<CR>
noremap <F12> :source ~/.vim/session/session_4<CR>
nnoremap <TAB> <C-W>w
nnoremap <s-TAB> <C-W>W

" my custom tab line and status line 
"
if !exists("g:merSection1FG")
  let g:merSection1FG=255
  let g:merSection1BG=33
  let g:merSection2FG=253
  let g:merSection2BG=27
  let g:merMainFG=253
  let g:merMainBG=21
  let g:merVisualFG=255
  let g:merVisualBG=202
  let g:merInsertFG=254
  let g:merInsertBG=28
  let g:merInactiveFG=249
  let g:merInactiveBG=237
endif

exec 'hi MERNormalSection ctermfg=' . g:merSection1FG . ' ctermbg=' . g:merSection1BG . ' cterm=NONE'
exec 'hi MERNormalSectionSep ctermfg=' . g:merSection1BG . ' ctermbg=' . g:merSection2BG . ' cterm=NONE'
exec 'hi MERVisualSection ctermfg=' . g:merVisualFG . ' ctermbg=' . g:merVisualBG . ' cterm=NONE'
exec 'hi MERVisualSectionSep ctermfg=' . g:merVisualBG . ' ctermbg=' . g:merSection2BG . ' cterm=NONE'
exec 'hi MERInsertSection ctermfg=' . g:merInsertFG . ' ctermbg=' . g:merInsertBG . ' cterm=NONE'
exec 'hi MERInsertSectionSep ctermfg=' . g:merInsertBG . ' ctermbg=' . g:merSection2BG . ' cterm=NONE'
 
exec 'hi MERMain ctermfg=' . g:merMainFG . ' ctermbg=' . g:merMainBG . ' cterm=NONE'
exec 'hi MERInactive ctermfg=' . g:merInactiveFG . ' ctermbg=' . g:merInactiveBG . ' cterm=NONE'
exec 'hi MERSection1 ctermfg=' . g:merSection1FG . ' ctermbg=' . g:merSection1BG . ' cterm=NONE'
exec 'hi MERSection1Sep ctermfg=' . g:merSection1BG . ' ctermbg=' . g:merSection2BG . ' cterm=NONE'
exec 'hi MERSection2 ctermfg=' . g:merSection2FG . ' ctermbg=' . g:merSection2BG . ' cterm=NONE'
exec 'hi MERSection2Sep ctermfg=' . g:merSection2BG . ' ctermbg=' . g:merMainBG . ' cterm=NONE'

exec 'hi MERTabMain ctermfg=' . g:merMainFG . ' ctermbg=' . g:merMainBG . ' cterm=NONE'
exec 'hi MERTab ctermfg=' . g:merSection2FG . ' ctermbg=' . g:merSection2BG . ' cterm=NONE'
exec 'hi MERTabSep ctermfg=' . g:merSection2BG . ' ctermbg=' . g:merSection1BG . ' cterm=NONE'
exec 'hi MERLastTabSep ctermfg=' . g:merSection2BG . ' ctermbg=' . g:merMainBG . ' cterm=NONE'
exec 'hi MERCurrentTab ctermfg=' . g:merSection1FG . ' ctermbg=' . g:merSection1BG . ' cterm=NONE'
exec 'hi MERCurrentTabSep ctermfg=' . g:merSection1BG . ' ctermbg=' . g:merSection2BG . ' cterm=NONE'
exec 'hi MERCurrentLastTabSep ctermfg=' . g:merSection1BG . ' ctermbg=' . g:merMainBG . ' cterm=NONE'

function! ActiveStatusOLD()
  let sl=""
"
  if mode() == 'n'
    let sl .= "%#MERNormalSection# NORMAL %#MERNormalSectionSep#\ue0b0"
  elseif mode() == 'v'
    let sl .= "%#MERVisualSection# VISUAL %#MERVisualSectionSep#\ue0b0"
  elseif mode() == 'i'
    let sl .= "%#MERInsertSection# INSERT %#MERInsertSectionSep#\ue0b0"
  else
    let sl .= "%#MERNormalSection# " . mode() . " %#MERNormalSectionSep#\ue0b0"
  endif

  let sl.="%#MERSection2#"
  let sl.="%{GitBranchWithSymbol()}"
  let sl.="%#MERSection2Sep#\ue0b4"
  let sl.="%#MERMain#"
  let sl.=" %n:%f %r%m"
  let sl.="%<"
  let sl.="%="
  let sl.="%{&fileformat}"
  let sl.=" | %{&fileencoding?&fileencoding:&encoding}"
  let sl.=" | %Y "
  let sl.="%#MERSection2Sep#\ue0b2"
  let sl.="%#MERSection2#"
  let sl.="%4p%% "
  let sl.="%#MERSection1Sep#\ue0b2"
  let sl.="%#MERSection1#"
  let sl.=" %4l:%-3c "
"  let sl.=" %4l "
  return sl
endfunction

"let g:LCARSBlack = 16
"let g:LCARSOrange = 208
"let g:LCARSMauve = 177
"let g:LCARSCrimson = 167
"let g:LCARSSky = 117
"let g:LCARSBlue = 63
"let g:LCARSAgua = 67
"let g:LCARSPurple = 99
"let g:LCARSPeach = 209
"let g:LCARSMagenta = 169
"let g:LCARSMelon = 223
"let g:LCARSSlate = 105
"let g:LCARSBurnt = 180
"let g:LCARSYellow = 222
"let g:LCARSGray = 60
"let g:LCARSRed = 196
"let g:LCARSMaroon = 160
"let g:LCARSPowder = 147

let g:LCARSBackground = 0

let g:LCARSBlack = 0
let g:LCARSBrightBlack = 8
let g:LCARSRed = 1
let g:LCARSBrightRed = 9
let g:LCARSBlue = 2
let g:LCARSBrightBlue = 10
let g:LCARSYellow = 3
let g:LCARSBrightYellow = 11
let g:LCARSViolet = 4
let g:LCARSBrightViolet = 12
let g:LCARSMauve = 5
let g:LCARSBrightMauve = 13
let g:LCARSPurple = 6
let g:LCARSBrightPurple = 14
let g:LCARSOrange = 7
let g:LCARSBrightOrange = 15

" color the split divider
"hi VertSplit ctermfg=0 ctermbg=0 cterm=NONE

" set the normal statusline colors to LCARS colors as this will be used by VIM
" when drawing the space between statusbars of adjacent splits
exec 'hi StatusLine ctermfg=' . g:LCARSBrightOrange . ' ctermbg=' . g:LCARSBackground . ' cterm=NONE'
exec 'hi StatusLineNC ctermfg=' . g:LCARSViolet . ' ctermbg=' . g:LCARSBackground . ' cterm=NONE'

exec 'hi LCARSText ctermfg=' . g:LCARSOrange . ' ctermbg=' . g:LCARSBackground . ' cterm=NONE'
exec 'hi LCARSOrange ctermfg=' . g:LCARSBlack . ' ctermbg=' . g:LCARSBrightOrange . ' cterm=NONE'
exec 'hi LCARSOrangeEnd ctermfg=' . g:LCARSBrightOrange . ' ctermbg=' . g:LCARSBackground . ' cterm=NONE'
exec 'hi LCARSViolet ctermfg=' . g:LCARSBlack . ' ctermbg=' . g:LCARSViolet . ' cterm=NONE'
exec 'hi LCARSVioletEnd ctermfg=' . g:LCARSViolet . ' ctermbg=' . g:LCARSBackground . ' cterm=NONE'
exec 'hi LCARSBlue ctermfg=' . g:LCARSBlack . ' ctermbg=' . g:LCARSBlue . ' cterm=NONE'
exec 'hi LCARSBlueEnd ctermfg=' . g:LCARSBlue . ' ctermbg=' . g:LCARSBackground . ' cterm=NONE'
exec 'hi LCARSPurple ctermfg=' . g:LCARSBlack . ' ctermbg=' . g:LCARSPurple . ' cterm=NONE'
exec 'hi LCARSPurpleEnd ctermfg=' . g:LCARSPurple . ' ctermbg=' . g:LCARSBackground . ' cterm=NONE'
exec 'hi LCARSYellow ctermfg=' . g:LCARSBlack . ' ctermbg=' . g:LCARSYellow . ' cterm=NONE'
exec 'hi LCARSYellowEnd ctermfg=' . g:LCARSYellow . ' ctermbg=' . g:LCARSBackground . ' cterm=NONE'
exec 'hi LCARSBrightBlue ctermfg=' . g:LCARSBlack . ' ctermbg=' . g:LCARSBrightBlue . ' cterm=NONE'
exec 'hi LCARSBrightBlueEnd ctermfg=' . g:LCARSBrightBlue . ' ctermbg=' . g:LCARSBackground . ' cterm=NONE'
exec 'hi LCARSRed ctermfg=' . g:LCARSBlack . ' ctermbg=' . g:LCARSRed . ' cterm=NONE'
exec 'hi LCARSRedEnd ctermfg=' . g:LCARSRed . ' ctermbg=' . g:LCARSBackground . ' cterm=NONE'
exec 'hi LCARSMauve ctermfg=' . g:LCARSBlack . ' ctermbg=' . g:LCARSMauve . ' cterm=NONE'
exec 'hi LCARSMauveEnd ctermfg=' . g:LCARSMauve . ' ctermbg=' . g:LCARSBackground . ' cterm=NONE'

function! ActiveStatus()

  let showfileformat = 1
  let showfileencoding = 1
  let showfiletype = 1
  let showcursorpos = 1
  let showbranch = 1
  let showmode = 1
  let showpercentage = 1
  
  let filename = expand("%:p")
  let gitbranch = "%{GitBranchWithSymbol()}"

  let staticdatalength = 61
  let datalength = staticdatalength + len(filename) + len(gitbranch)

  if datalength > winwidth(0)
    let filename = expand("%:p:t")
	let datalength = staticdatalength + len(filename) + len(gitbranch)
  endif

  if datalength > winwidth(0)
    let showfileformat = 0
	let datalength = datalength - 7
  endif

  if datalength > winwidth(0)
    let showfiletype = 0
	let datalength = datalength - 11
  endif

  if datalength > winwidth(0)
    let showfileencoding = 0
	let datalength = datalength - 10
  endif

  if datalength > winwidth(0)
    let showpercentage = 0
	let datalength = datalength - 6
  endif

  if datalength > winwidth(0)
    let showcursorpos = 0
	let datalength = datalength - 11
  endif

  if datalength > winwidth(0)
    let showbranch = 0
	let datalength = datalength - len(gitbranch)
  endif

  if datalength > winwidth(0)
    let showmode = 0
	let datalength = datalength - 9
  endif



  let sl = ""
  let sl .= "%#LCARSOrangeEnd#\ue0b6"
  let sl .= "%#LCARSOrange#"
  let sl .= " "
  let sl .= "%#LCARSText#"
  let sl .= " "
  let sl .= "%<"

  if showmode == 1

    if mode() == 'n'
      let sl .= "%#LCARSBlue# NORMAL "
    elseif mode() == 'v'
      let sl .= "%#LCARSYellow# VISUAL "
    elseif mode() == 'i'
      let sl .= "%#LCARSRed# INSERT "
    else
      let sl .= "%#LCARSBlue# " . mode() . " "
    endif

"    let sl .= "%#LCARSBlue#"
"    let sl .= " NORMAL "
    let sl .= "%#LCARSText#"
    let sl .= " "
  endif

  if showbranch == 1
    let sl .= "%#LCARSViolet#"
    let sl .= gitbranch
  endif

  let sl .= "%#LCARSText#"
  let sl .= " %n:" . filename . " %r%m "
  let sl .= "%#LCARSOrange#"
  let sl .= "%="
  let sl .= "%#LCARSText#"
  let sl .= " "

  if showfileformat == 1
    let sl .= "%#LCARSPurple#"
    let sl .= " %{&fileformat} "
    let sl .= "%#LCARSText#"
    let sl .= " "
  endif

  if showfileencoding == 1
    let sl .= "%#LCARSYellow#"
    let sl .= " %{&fileencoding?&fileencoding:&encoding} "
    let sl .= "%#LCARSText#"
    let sl .= " "
  endif

  if showfiletype == 1
    let sl .= "%#LCARSBrightBlue#"
    let sl .= " %Y "
    let sl .= "%#LCARSText#"
    let sl .= " "
  endif

  if showpercentage == 1
    let sl .= "%#LCARSMauve#"
    let sl.="%4p%% "
    let sl .= "%#LCARSText#"
    let sl .= " "
  endif

  if showcursorpos == 1
    let sl .= "%#LCARSViolet#"
    let sl .= " %4l:%-3c "
    let sl .= "%#LCARSText#"
    let sl .= " "
  endif

  let sl .= "%#LCARSOrange#"
  let sl .= " "
  let sl .= "%#LCARSOrangeEnd#\ue0b4"

  return sl

endfunction

function! InactiveStatusOLD()
  let sl=""
  let sl.="%#MERInactive#"
  let sl.=" %n:%t %r%m"
  let sl.="%<"
  let sl.="%="
  let sl.=" %4l:%-3c "
  return sl
endfunction

function! InactiveStatus()
  let sl = ""
  let sl .= "%#LCARSVioletEnd#\ue0b6"
  let sl .= "%#LCARSViolet#"
  let sl .= " "
  let sl .= "%#LCARSText#"
  let sl .= " "
  let sl .= "%#LCARSViolet#"
  let sl .= " %<"
  let sl .= "%F"
  let sl .= "%="
  let sl .= "%#LCARSText#"
  let sl .= " "
  let sl .= "%#LCARSViolet#""
  let sl .= " "
  let sl .= "%#LCARSVioletEnd#\ue0b4"

  return sl

endfunction

function! GetMode()
  if mode() == 'n'
    return '%#MERNormalSection#NORMAL%#MERNormalSectionSep#\ue0b0'
  elseif mode() == 'v'
    return "%#MERVisualSection#VISUAL%#MERVisualSectionSep#\ue0b0"
  elseif mode() == 'i'
    return "%#MERInsertSection#INSERT%#MERInsertSectionSep#\ue0b0"
  else
    return mode()
endfunction


" call our color overrides script to override colors we want static
" no matter which color scheme we use (gray tabs, color columns, etc)
" - we have to do this via autocmd's otherwise if we load sessions
" it overrides these changes and only uses base color scheme
"autocmd VimEnter * source ~/.vim/mer_color_overrides.vim
"autocmd SessionLoadPost * source ~/.vim/mer_color_overrides.vim

set statusline=%!ActiveStatus()

autocmd WinEnter * setlocal statusline=%!ActiveStatus()
autocmd WinLeave * setlocal statusline=%!InactiveStatus()


function! MyTabLineOLD()

	let s = ''
	
	for i in range(tabpagenr('$'))
		let tabnr = i + 1 " range() starts at 0
		let winnr = tabpagewinnr(tabnr)
		let buflist = tabpagebuflist(tabnr)
		let bufnr = buflist[winnr - 1]
		let bufname = fnamemodify(bufname(bufnr), ':t')

		let s .= '%' . tabnr . 'T'
		let s .= (tabnr == tabpagenr() ? '%#MERCurrentTab#' : '%#MERTab#')
		let s .= ' ' . tabnr 

		let n = tabpagewinnr(tabnr,'$')
		if n > 1 | let s .= ':' . n | endif

		let bufmodified = getbufvar(bufnr, "&mod")
		if bufmodified | let s .= '+' | endif
	
		let s .= empty(bufname) ? ' [No Name] ' : ' ' . bufname . ' '

		let simplesep = 0
		if (tabnr < tabpagenr('$'))
			if (tabpagenr() != tabnr) && (tabpagenr() != tabnr + 1)
				let s .= ''
				let simplesep = 1
			endif
		endif

		if simplesep == 0
			if tabnr == tabpagenr('$')
				let s .= (tabnr == tabpagenr() ? "%#MERCurrentLastTabSep#\ue0b0" : "%#MERLastTabSep#\ue0b0")
			else
				let s .= (tabnr == tabpagenr() ? "%#MERCurrentTabSep#\ue0b0" : "%#MERTabSep#\ue0b0")
			endif
		endif

	endfor

	" after the last tab fill with TabLineFill and reset tab page nr
	let s .= '%#MERMain#%T'

	if tabpagenr('$') > 1
		let s .= '%='
		let s .= "%#MERLastTabSep#\ue0b2"
		let s .= '%#MERTab#%999X X '
	endif
	
	return s

endfunction

function! MyTabLine()

	let s = ''
	
	let s .= "%#LCARSOrangeEnd#\ue0b6"
	let s .= "%#LCARSOrange#"
	let s .= " %#LCARSText# "
	
	for i in range(tabpagenr('$'))
		let tabnr = i + 1 " range() starts at 0
		let winnr = tabpagewinnr(tabnr)
		let buflist = tabpagebuflist(tabnr)
		let bufnr = buflist[winnr - 1]
		let bufname = fnamemodify(bufname(bufnr), ':t')

		let s .= '%' . tabnr . 'T'
		let s .= (tabnr == tabpagenr() ? '%#LCARSBlue#' : '%#LCARSYellow#')
		let s .= ' ' . tabnr 

		let n = tabpagewinnr(tabnr,'$')
		if n > 1 | let s .= ':' . n | endif

		let bufmodified = getbufvar(bufnr, "&mod")
		if bufmodified | let s .= '+' | endif
	
		let s .= empty(bufname) ? ' [No Name] ' : ' ' . bufname . ' '

		let s .= "%#LCARSText#"
		let s .= " "

	endfor

	" after the last tab fill with TabLineFill and reset tab page nr
	let s .= '%#LCARSOrange#%T'
	let s .= '%='

	if tabpagenr('$') > 1
		let s .= "%#LCARSText# "
		let s .= '%#LCARSBlue#%999X X '
	endif

	let s .= "%#LCARSText# "
	let s .= "%#LCARSOrange# "
	let s .= "%#LCARSOrangeEnd#\ue0b4"
	
	return s

endfunction

set tabline=%!MyTabLine()
